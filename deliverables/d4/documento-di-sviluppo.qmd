---
title: | 
  ![](../../.common-media/logo-unitn-ardeeno-512.png){width=10cm}

  Ardeeno WebApp
subtitle: |
  T41-SE22

  D4-Documento di Sviluppo

  v0.3
author: [alessandro.manfucci@studenti.unitn.it, enrico.cescato@studenti.unitn.it ,m.sottocornola-1@studenti.unitn.it]
date: "26-12-2022"
lang: it
format:
  pdf:
    include-in-header:
      text: |
        \usepackage{graphicx}
        \usepackage{wrapfig}
    documentclass: article
    classoption: titlepage
    toc: true
    toc-title: Indice
    papersize: a4
    number-sections: true
    geometry:
    - top=1in
    - bottom=1in
    - right=1in
    - left=1in
---

\pagebreak
# Abstract {.unlisted .unnumbered}
In questo primo sprint di sviluppo (D4v1.0), ci si limita ai Requisiti Funzionali:

- [RF1 Visualizzazione presentazione](#a)
- [RF5 Autenticazione](#a)
- [RF5.1 Logout](#a)
- [RF11 Visualizzazione impianti acquistati](#a)
- [RF11.1 Visualizzazione singolo impianto (Dashboard)](#a)
- [RF12 Visualizzazione misurazioni su heatmap](#a)

Si veda il Documento di Specifica per i casi d'uso associati a questi RF -- che verranno quindi implementati.

Per i Requisiti Non Funzionali ci si limita al [RNF2 Sicurezza](#a) ed in particolare alla proprietà 'Password salvata non in chiaro'.

Il progetto è stato suddiviso in due repositories: `ardeeno-frontend`, contenente il progetto React, ed `ardeeno-backend`, il quale si interfaccia con cloud.mongodb.com e fornisce le API al FrontEnd.

# BackEnd
Il BackEnd è stato realizzato con il runtime environment `Node.js` sul repository [t41-se22/ardeeno-backend]([https://(https://github.com/T41-SE22/ardeeno-backend))

## Struttura

```bash
t41-se22/ardeeno-backend/
|---controllers/
|---coverage/
|---middleware/
|---models/
|---node_modules/
|---routes/
|---schemas/
|---tests/
|---utils/
|---.env
|---app.js
|---babel.config.js
|---package.json
|---Procfile
|---README.md
|---server.js
|---swagger3.json
```
La struttura del BackEnd è stata suddivisa in più cartelle, in particolare:

- **controllers**: contiene le funzioni che costituiscono le vere e proprie API
- **coverage**: contiene le informazioni sulla copertura del codice garantita dai test `Jest`
- **middleware**: contiene quelle funzioni comuni a tutte le API -- autorizzazione e controllo del token -- come dal paradigma di sviluppo di `Node`
- **routes**: contiene gli end-point delle API
- **utils**: contiene quelle funzioni generiche, di supporto
- **models**: contiene i `Model` degli Schemas utilizzati sul database `mongodb`
- **schemas**: contiene gli Schemas utilizzati sul database `mongodb`
- **tests**: contiene i file di test `Jest` ed il file di configurazione del mock-database
- **app.js**: contiene la configurazione degli endpoint tramite `express` e la configurazione della connessione a `mongodb` tramite `mongoose`
- **Procfile**: contiene la configurazione di `Heroku`
- **server.js**: contiene la configurazione del server di rete
- **swagger3.json**: contiene la documentazione Open API 3.0 in formato `json`

## Dependencies
```js
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "http-status-codes": "^2.2.0",
    "jsonwebtoken": "^8.5.1",
    "mongodb-memory-server": "^8.10.2",
    "mongoose": "^6.8.0",
    "swagger-ui-express": "^4.6.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.5",
    "@babel/preset-env": "^7.20.2",
    "babel-jest": "^29.3.1",
    "jest": "^29.3.1",
    "supertest": "^6.3.3"
  }
```
Si descrivono nello specifico le librerie più rilevanti:

- **bcrypt**: libreria che fornisce funzioni di salted-hashing con multipli hashing-rounds, in maniera stateless
- **cors**: libreria per gestire il Cross-Origin Resource Sharing -- necessaria per adempiere al protocollo HTTP
- **dotenv**: libreria che carica come variabili globali le costanti in `.env`
- **http-status-codes**: libreria che contiene come costanti i codici di stato http più rilevanti
- **jsonwebtoken**: libreria che fornisce funzioni di generazione di token json come dall'[RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)
- **mongodb-memory-server**: libreria che permette la creazione di un database `mongodb` in memoria RAM -- utile per creare mock-database da utilizzare nella fase di testing
- **swagger-ui-express**: libreria che genera a partire da un file `.json/.yaml` pagine `html` per la documentazione delle API
- **jest**: libreria che effettua il testing dell'applicazione
- **supertest**: libreria che mette a disposizione utili convenience-methods per inoltrare richieste http e fare assertions sulle risposte http; utilizzata per effettuare il testing dell'applicazione

## Database

Il BackEnd si interfaccia con un database `mongodb` in hosting su [MongoDB Atlas](https://www.mongodb.com/atlas). MongoDB è un database document-based, non relazionale. Inoltre, si utilizza `mongoose` per interfacciarsi con il database in maniera più strutturata, definendo degli Schemas.
Il database `ardeeno-db` è suddiviso in più collections, per ognuna delle quali si definisce uno Schema `mongoose`:

- **Utenti**

```javascript
{
  email: {type:String, required:true, unique:true},
  password: {type:String, required:true},
  indirizzo: {type:String, required:true},
  nome: {type:String, required:true},
  cognome: {type:String, required:true},
  telefono: {type:String, required:true, unique:true},
  ruolo: {type:String,
    enum:['cliente', 'tecnico',
      'supervisore', 'amministratore'],
    default:'cliente'},
  isEmailConfermata: {type:Boolean, default:true},
  impiantiAcquistati: {type:[{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Impianto'}], default:[]},
  cf: {type:String, unique:true, sparse:true},
  isDimesso: {type:Boolean, default:false}
}
```

- **Modelli**

```javascript
{
  nome: {type:String, required:true, unique:true},
  tipo: {type:String, required:true},
  immagine: {type:String, required:true},
  costo: {type:Map, required:true},//in euro, senza iva
  numSensori: {type:Number, required:true},
  superficie: {type:Number, required:true},//consigliata in km^2
  pi: {type:Number, required:true},
  parametri: {type:[{type:Map}], required:true},
}
```

- **Impianti**

```javascript
{
  modello: {type: mongoose.Schema.Types.ObjectId, ref:'Modello', required:true},
  indirizzo: {type:String, required:true},
  lat: {type:Number, required:true},
  long: {type:Number, required:true},
  fattura: {type:String, required:true},
  superficie: {type:Number, required:true},//effettiva in km^2
  dataAcquisto: {type:Date, required:true},
  dataDismissione: {type:Date},
  isDismesso: {type:Boolean, default:false},
  sensori: {type:[{type: mongoose.Schema.Types.ObjectId, ref:'Sensore'}], default:[]}
}
```

- **Sensori**

```javascript
{
  impianto: {type: mongoose.Schema.Types.ObjectId, ref:'Impianto', required:true},
  lat: {type:Number, required:true},
  long: {type:Number, required:true},
  dataDismissione: {type:Date},
  isDismesso: {type:Boolean, default:false}
}
```

- **Snapshots_&lt;impianto._id&gt;**

In questo caso, per ogni Impianto si crea una nuova collections con lo stesso Schema `mongoose`; questo perché le query sugli Snapshots sono sempre -- nel nostro contesto -- su un solo impianto. Inoltre, si stima dai [RNF](#a) un utilizzo con numerosi impianti, che producono una notevole quantità di snapshot -- questa struttura aiuta a mantenere un'importante efficienza. Le collections create sono di tipo `capped`, ovvero hanno un massimo numero di documenti; questo, come dalla documentazione ([link](https://www.mongodb.com/docs/v6.0/core/capped-collections/)), mantiene l'ordine di inserimento dei documenti -- che è in maniera ordinata, e dunque non si necessita di un riordinamento al momento della query.

```javascript
{
  impianto: {type: mongoose.Schema.Types.ObjectId,
    ref:'Impianto', required:true},
  date: {type:Date, required:true, unique:true}
}
```

- **Misurazioni_&lt;impianto._id&gt;**

Come nel caso precedente, anche per le Misurazioni si crea una nuova collection per ogni Impianto con lo stesso Schema `mongoose`, di tipo `capped`.

```javascript
{
  sensore: {type:mongoose.Schema.Types.ObjectId,
    ref:'Sensore', required:true},
  date: {type:Date, required:true},
  valori: {type:Map, required:true}
}
```

## APIs

### Resources Extraction from the Class Diagram

![Resources Extraction](.media/resources-extraction.png){fig-pos=H}

### Resources Models

![Resources Models](.media/resources-models.png){fig-pos=H}

### Sviluppo
<!--le devo descrivere proprio tutte? Devo mettere tutto il codice o solo le firme?-->
Si è utilizzato uno stile di programmazione con `async/await` e gestione degli errori -- anche asincroni -- con `try/catch`.

### Documentazione OpenAPI 3.0
Le API sono state documentate seguendo lo standard Open API 3.0 e sono visibili ad [api.ardeeno.cloud/api-docs](http://api.ardeeno.cloud/api-docs). Si documentano tutti i possibili messaggi di errore nella sezione `examples`. Si danno inoltre `examples` per i messaggi di richiesta della funzione `genToken` in `POST /auth`.

L'applicazione prototipo dispone di un Utente pre-registrato, a cui è associato un Impianto con sensori, snapshots e misurazioni. Le credenziali sono:
```
email: mario.rossi@gmail.com
password: password
```
Le credenziali sono appunto visibili sugli `examples` di `genToken` ([api.ardeeno.cloud](http://api.ardeeno.cloud/api-docs/#/Authentication/post_auth)).

<!--Devo mettere la documentazione effettiva o devo solo spiegare come è stata gestita la documentazione? (Standard Swagger)-->

### Testing Jest
Il Testing è stato gestito con la libreria `Jest` ed `supertest`. Inoltre, si è utilizzato `mongodb-memory-server` per creare -- al momento del testing -- un mock-database con dati sempre costanti, così da fare assertions direttamente sul body delle risposte.

Per ogni API definita, si sono effettuati tutti i casi di test sul successo (2xx SUCCESS) e sugli errori dell'Utente (4xx CLIENT_ERROR) -- ma non sui possibili errori interni (5xx SERVER_ERROR). Inoltre, si sono testate quelle solo risposte definite esplicitamente nello sviluppo, e non quelle gestite implicitamente da `Node.js`.

Dal report sul coverage di `Jest` si nota che si sono coperti il `57.99%` dei branch -- quelli non coperti sono appunto quei branch che gestiscono gli errori (5xx SERVER_ERROR), i quali sono principalmente gli errori del server `mongodb`.

![Coverage](./.media/coverage.png){width=16cm fig-pos=H}

![Coverage Controllers](./.media/coverage-controllers.png){width=16cm fig-pos=H}

![Coverage Middleware](./.media/coverage-middleware.png){width=16cm fig-pos=H}

![Coverage Models](./.media/coverage-models.png){width=16cm fig-pos=H}

![Coverage Ruotes](./.media/coverage-routes.png){width=16cm fig-pos=H}

![Coverage Schemas](./.media/coverage-schemas.png){width=16cm fig-pos=H}

![Coverage Tests](./.media/coverage-tests.png){width=16cm fig-pos=H}


# FrontEnd

Il FrontEnd è stato realizzato con `React 18`, seguendo i suoi principi (*The React Way*) ed utilizzando la libreria [coreui-free-react-admin-template](https://github.com/coreui/coreui-free-react-admin-template). La WebApp è quindi una Single Page Application.

## Struttura
```bash
t41-se22/ardeeno-frontend/
|---node_modules/
|---public/
|---src/
|   |---assets/
|   |   |---brand/
|   |   |---fonts/
|   |   |---images/
|   |---components/
|   |---layout/
|   |---scss/
|   |---views/
|   |   |---appContent/
|   |   ...
|   |   |---pages/
|   |   ...
|   |---_nav.js
|   |---App.js
|   |---index.js
|---.env
|---.eslintrc.json
|---.jsconfig.json
|---LICENSE
|---package.json
|---Procfile
|---README.md
```
La struttura del FrontEnd è stata suddivisa in più cartelle, in particolare:

- **public**: contiene quei file scaricati dal browser -- che si occupano di configurare l'ambiente React
- **src**: contiene i file React
- **src/components**: contiene le componenti React dell'`AppLayout`, tra cui AppContent, che effettua inoltre il routing tra i contenuti dell'applicazione
- **src/layout**: contiene la componente React `AppLayout`, che crea il layout instanziando `Sidebar`, `Header`, `Footer` ed `AppContent`
- **src/views**: contiene le viste React -- dove una vista è un contenuto dell'applicazione o una pagina a sé stante dall'`AppLayout`
- **src/views/appContent**: contiene le viste caricate da AppContent -- ovvero l'applicazione vera e propria
- **src/views/pages**: contiene le pagine a sé stante dall'`AppLayout`, che sono *esterne* all'applicazione (`Login`, `Registrazione`, `Error404`, ...)
- **src/App.js**: contiene la configurazione dell'applicazione React, ovvero esporta la variabile di ambiente `API_URL`, fornisce il contesto con `loggedUser`, `selImp` (a partire dai *persistent data* di `localforage`) ed effettua il routing verso l'`AppLayout` e verso le `pages` esterne ad `AppLayout`
- **src/index.js**: è la radice dell'applicazione React -- instanzia `App.js`
- **.eslintrc.json**: contiene le impostazioni per il linting dei file React ed JSX (Javascript XML) -- sono state seguite le buone norme di programmazione react suggerite dal linting
- **LICENSE**: contiene la licenza della libreria `coreui`, da includere obbligatoriamente
- **Procfile**: contiene la configurazione di `Heroku`


## Dependencies
```js
  "dependencies": {
    "@coreui/chartjs": "^3.0.0",
    "@coreui/coreui": "^4.2.1",
    "@coreui/icons": "^2.1.0",
    "@coreui/icons-react": "^2.1.0",
    "@coreui/react": "^4.3.1",
    "@coreui/react-chartjs": "^2.1.0",
    "@coreui/utils": "^1.3.1",
    "axios": "^1.2.1",
    "chart.js": "^3.9.1",
    "classnames": "^2.3.1",
    "core-js": "^3.24.1",
    "deck.gl": "^8.8.20",
    "jquery": "^3.6.2",
    "localforage": "^1.10.0",
    "prop-types": "^15.8.1",
    "pullstate": "^1.25.0",
    "react": "^18.2.0",
    "react-app-polyfill": "^3.0.0",
    "react-dom": "^18.2.0",
    "react-leaflet": "^4.2.0",
    "react-map-gl": "^5.3.0",
    "react-persistent-store-manager": "^1.1.1",
    "react-redux": "^8.0.2",
    "react-router-dom": "^6.3.0",
    "react-scripts": "5.0.1",
    "redux": "4.2.0",
    "sass": "^1.54.4",
    "simplebar-react": "^2.4.1",
    "web-vitals": "^2.1.4"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.3.0",
    "@testing-library/user-event": "^14.4.3",
    "@typescript-eslint/eslint-plugin": "^5.47.0",
    "@typescript-eslint/parser": "^5.47.0",
    "eslint": "^8.30.0",
    "eslint-plugin-react": "^7.31.11",
    "eslint-plugin-react-hooks": "^4.6.0"
  }
```

Oltre a `coreui` ed alle sue dependencies si sono utilizzate molte altre librerie, tra cui le più rilevanti sono:

- **axios**: libreria che mette a disposizione convenience-methods per effettuare richieste http AJAX
- **deck.gl**: libreria che agregga e renderizza Big Data su mappe geografiche, in maniera bidimensionale ma anche tridimensionale
- **localforage**: libreria che, appoggiandosi su **localstorage**, mette a disposizione funzioni per il salvataggio di dati sul browser; è stata utilizzata per mantenere `persistent data` dell'Utente Autenticato
- **react-leaflet**: libreria che permette la renderizzazione di mappe OpenStreetMap
- **sass**: libreria che permette di ricompilare i fogli di stile `coreui` con la palette di colori `ardeeno`

## User Flows

![Login](.media/login.png){fig-pos=H width=16cm}

![Logout](.media/logout.png){fig-pos=H width=10cm}

![Dashboard](.media/dashboard.png){fig-pos=H width=12cm}

![Heatmap](.media/heatmap.png){fig-pos=H width=12cm}

## Sviluppo

![App Layout](.media/layout.png){fig-pos=H width=10cm}

Si descrivono le componenti ad-hoc sviluppate appositamente per `ardeeno` a partire da `coreui` e presenti in `/src/views/appContent` ed `/src/views/pages`.
Si è utilizzato uno stile `React` con `function-components` ed `stateful-function-components` (`hooks`).

###

## Schermate

# GitHub Repository
Per entrambi i repositories il flusso di lavoro è stato organizzato su più branch:
```{mermaid}
%%| fig-width: 6
%%| fig-height: 2
  gitGraph
    commit
    branch hot-patch
    commit
    checkout main
    merge hot-patch
    commit
    branch develop
    commit
    checkout develop
    branch feature
    commit
    checkout develop
    merge feature
    checkout main
    merge develop
    checkout develop
    branch patch
    commit
    checkout develop
    merge patch
```
Inoltre, per quanto riguarda il BackEnd si sono utilizzate delle GitHub Actions per automatizzare il testing con Jest (per le pull request sul `develop` e sul `main`)
<!--mermaid workflow, git workflow file, kanban board-->

# Deployment
Si è utilizzato Heroku per avere un Fast Deployment agli URL:

- [www.ardeeno.cloud](http://www.ardeeno.cloud)
- [api.ardeeno.cloud](http://api.ardeeno.cloud)

I record CNAME sono stati impostati tramite la CLI di Heroku
<!--schermata del deployment su heroku, parlare del dns, va aggiunto su heroku??-->