---
title: | 
  ![](../../.common-media/logo-unitn-ardeeno-512.png){width=10cm}

  Ardeeno WebApp
subtitle: |
  T41-SE22

  D3-Documento di Architettura

  v0.3
author: [alessandro.manfucci@studenti.unitn.it, enrico.cescato@studenti.unitn.it ,m.sottocornola-1@studenti.unitn.it]
date: "09-12-2022"
lang: it
format:
  pdf:
    include-in-header:
      text: |
        \usepackage{graphicx}
        \usepackage{wrapfig}
    documentclass: article
    classoption: titlepage
    toc: true
    toc-title: Indice
    papersize: a4
    number-sections: true
    geometry:
    - top=1in
    - bottom=1in
    - right=1in
    - left=1in
syntax-definitions: 
  - .ocl.xml
syntax-highlight: github
---

\pagebreak
# Abstract {.unlisted .unnumbered}

Questo documento, a partire dalle componenti precedentemente definite, descrive l'architettura in classi del sistema da realizzare. L'obiettivo è fornire al team di sviluppo una seconda -- e più dettagliata -- architettura del software da sviluppare. Si utilizza il diagramma delle classi UML e il linguaggio OCL (*Object Constraint Language*).

# Diagramma delle classi
Questo capitolo presenta il diagramma delle classi UML del sistema. In particolare si descrivono le singole classi nel loro scopo e contesto, raggruppandole secondo una certa correlazione logica. Le classi descritte rappresentano un'astrazione del codice che sarà eseguito sia lato client, che lato server -- omettendo tuttavia la logica di presentazione.

A partire dal diagramma dei componenti si crea per ogni componente almeno una classe; dalle interfacce si derivano gli attributi e i metodi delle classi. Infine, si identificano le relazioni.

Per quanto riguarda le classi, useremo gli stereotipi:

- `<<static>>`: per classi accessibili senza essere instanziate, spesso da implementare solo lato server
- `<<abstract class>>`: per classi non instanziabili ma con metodi concreti
- `<<datatype>>`: per classi senza metodi (impliciti o espliciti)
- `<<enum>>`: per definire nuovi tipi con un dominio limitato agli elementi elencati

Per quanto riguarda gli attributi, si specifica il tipo solo quando vi è ambiguità o si vuole porre un ulteriore vincolo; per quanto riguarda i metodi, per lo stesso principio, ometteremo spesso valore di ritorno, argomenti e tipo degli argomenti. Ometteremo quindi anche la visibilità di metodi e attributi.
Inoltre, si considerano impliciti i metodi getter/setter sugli attributi di ogni classe -- verrano resi espliciti per dare enfasi al dato attributo. Con il tipo `object` si intende un generico oggetto di cui non ci interessa al momento conoscere la classe.

Per quanto riguarda le relazioni si specifica nome, molteplicità (con notazione *look-ahead*), ruolo e navigabilità solo quando è rilevante. Indicheremo la relazione di dipendenza solo quando non è evidente dal tipo degli attributi, dai parametri dei metodi o dalle altre relazioni -- o comunque per dare enfasi alla dipendenza.

Diamo il postfisso `Manager` a tutte quelle classi che gestiscono le interazioni con i sistemi esterni.

## Utente
![Utente](./.media/utente.png){width=16cm fig-pos=H}
Dal comp. "Gestione Autenticazione" si definisce la classe DataLayerManager, che gestisce le interazioni con il DataLayer. Comprende molti metodi volutamente lasciati impliciti, per non porre vincoli non necessari al team di sviluppo. Certamente vi sarà un metodo *setupConnection()* per stabilire la connessione con il DataLayer tramite una *connUri*. La maggior parte delle classi utilizza i suoi metodi -- ovvero ne è dipendente (ma queste relazioni sono omesse dal diagramma).

Dal comp. "Gestione Autenticazione" si definisce la classe AuthManager, e dalle due interfacce fornite si hanno i corrispettivi metodi. Inoltre, vi è l'attributo *secret*, utilizzato in *genToken()* per avere la garanzia di autenticità del token. L'Utente invoca *AuthManager.genToken()* nel metodo *login()*, ed invoca *AuthManager.checkAuth()* nei metodi *getDati(), modificaDati()* -- dunque ne è dipendente.

Dal comp. "Gestione Gmail" si definisce la classe EmailManager con il metodo *sendEmail(email).* L'Utente ne è dipendente.

Dai corrispettivi componenti si definiscono le classi

## Vetrina
![Vetrina](./.media/vetrina.png){width=16cm fig-pos=H}

## Impianto
![Impianto](./.media/impianto.png){width=16cm fig-pos=H}

## Dipendenti
![Dipendenti](./.media/dipendenti.png){width=16cm fig-pos=H}

## Diagramma delle classi complessivo
Alla pagina successiva si trova il diagramma leggibile.

<!--concatenare il pdf!-->

![Anteprima diagramma delle classi complessivo](./.media/complessivo.png){width=16cm fig-pos=H}

\pagebreak
# Codice in OCL
Questo capitolo presenta particolari proprietà sugli attributi e sulle operazioni delle varie classi (invarianti, pre-condizioni e post-condizioni). Come nel capitolo precedente, le classi sono raggruppate secondo una certa correlazione logica.  
Si utilizza il linguaggio OCL, che estende lo standard UML.

## Utente
![Utente](./.media/utente-ocl.png){width=16cm fig-pos=H}

### Utente
```ocl
context Utente::newCodiceConferma()
pre: NOT isEmailConfermata
```
```ocl
context Utente::login(email, pw)
pre: isEmailConfermata = true
```

### Dipendente
```ocl
context Dipendente inv:
isEmailConfermata = true
```
```ocl
context Dipendente::login(email, pw)
pre: NOT isDimesso
```
```ocl
context Dipendente::dimetti()
pre: NOT isDimesso
post: isDimesso
```

### Cliente
```ocl
context Cliente::selezionaImpianto()
post: seleImpianto <> null
```
```ocl
context Cliente::getMisurazioniImp()
pre: seleImpianto <> null
```
```ocl
context Cliente::getHeatmapImp()
pre: seleImpianto <> null
```
```ocl
context Cliente::richiediRiparazioneImp(mot)
pre: seleImpianto <> null AND 
	NOT seleImpianto.isDismesso
```

## Vetrina
![Vetrina](./.media/vetrina-ocl.png){width=16cm fig-pos=H}

### Modello
```ocl
context Modello inv:
superficie > 0 AND
numSensori > 0
```

### ProductReview
```ocl
context ProductReview inv:
stars >= 1 AND stars <= 5
```

```ocl
context ProductReview inv:
stars >= 1 AND stars <= 5
```

### ServiceReview
```ocl
context ServiceReview inv:
stars >= 1 AND stars <= 5
```

### Costo
```ocl
context Costo inv:
getCosto() > 0
```

### Vetrina
```ocl
context Vetrina::selezionaModello()
post: seleModello <> null AND
       inVendita->includes(seleModello)
```

```ocl
context Vetrina::getProdReviewsModello()
pre: seleModello <> null
```

```ocl
context Vetrina::filtraProdReviews(stelle, data)
pre: seleModello <> null
```

## Impianto
![Impianto](./.media/impianto-ocl.png){width=16cm fig-pos=H}

### Impianto
```ocl
context Impianto inv:
(isDismesso IIF dataDismissione = null) AND superficie > 0 AND
dataAcquisto <> null AND
(isDismesso IMPLIES dataDismissione >= 	dataAcquisto)
```

```ocl
context Impianto::dismetti()
pre: NOT isDismesso

post: isDismesso AND
	dataDismissione = now()
```

```ocl
context Impianto::addSensore
(sensore, coord)
pre: NOT self.isDismesso AND
	NOT sensore.isDismesso AND
	sensore.impianto = null

post: sensore.impianto = self AND
	sensore.coord = coord
```

```ocl
context Impianto::dismettiSensore(sensore)
pre: NOT self.isDismesso AND
	NOT sensore.isDismesso AND
	sensore.impianto = self

post: sensore.isDismesso AND
	sensore.dataDismissione = now()
```

```ocl
context Impianto::richiediIntervento
(tipo, mot)
pre: NOT isDismesso
```

### Sensore
```ocl
context Sensore inv:
(impianto = null IIF coord = null) AND
(isDismesso IIF dataDismissione <> null) AND
(impianto = null IMPLIES NOT isDismesso)
```

```ocl
context Sensore::installa
(impianto, coord)
pre: NOT isDismesso AND
	self.impianto = null

post: self.impianto = impianto AND
	self.coord = coord
```

```ocl
context Sensore::dismetti()
pre: NOT isDismesso

post: isDismesso AND
	dataDismissione = now()
```

### Heatmap
```ocl
context Heatmap inv:
snapshots->includes(currSnapshot)
```

## Dipendenti
![Dipendenti](./.media/dipendenti-ocl.png){width=16cm fig-pos=H}

### Intervento
```ocl
context Intervento inv:
dataRichiesta <> null AND
(motivazione <> null IIF tipo = riparazione)
(tecnico = null IIF dataAssegnazione = null) AND
(isConcluso IIF resoconto <> null) AND
(dataAssegnazione <> null IMPLIES 	dataAssegnazione >= dataRichiesta)
```

```ocl
context Intervento::assegna(tecnico, data)
pre: self.tecnico = null AND
	self.dataAssegnazione = null

post: self.tecnico = tecnico AND
	self.dataAssegnazione = data
```

```ocl
context Intervento::concludi(resoconto)
pre: NOT isConcluso

post: self.resoconto = resoconto AND
	isConcluso
```

### Tecnico
```ocl
context Tecnico inv:
interventiAssegnati->includes(seleIntervento) AND
interventiAssegnati->forAll( i | i.tecnico = self)
```

```ocl
context Tecnico::getMisurazioniImp()
pre: seleIntervento <> null AND
NOT seleIntervento.isConcluso
```

```ocl
context Tecnico::getHeatmapImp()
pre: seleIntervento <> null AND
NOT seleIntervento.isConcluso
```

```ocl
context Tecnico::getInterventiImp()
pre: seleIntervento <> null AND
NOT seleIntervento.isConcluso
```

```ocl
context Tecnico::modificaImpianto()
pre: seleIntervento <> null AND
NOT seleIntervento.isConcluso
```

```ocl
context Tecnico::concludiIntervento(res)
pre: seleIntervento <> null AND
	NOT seleIntervento.isConcluso

post: seleIntervento.resoconto = res AND
	seleIntervento.isConcluso
```

### Supervisore
```ocl
context Supervisore::assegnaIntervento
(tec, data)
pre: seleIntervento <> null AND
	seleIntervento.tecnico = null AND
	(tec.interventiAssegnati->forAll( i |
		i.dataAssegnazione <> data))

post: seleIntervento.tecnico = tec AND
	seleIntervento.dataAssegnazione = now()
```

## Diagramma delle classi complessivo con codice OCL
Alla pagina successiva si trova il diagramma leggibile.

<!--concatenare il pdf!-->

![Anteprima diagramma delle classi complessivo con codice OCL](./.media/complessivo-ocl.png){width=16cm fig-pos=H}